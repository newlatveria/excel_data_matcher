<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Data Utility (IndexedDB & Grouping) - Final Fixed</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7.1.1/build/umd.js"></script> 
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <style>
        /* --- CORE STYLES --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a2e; color: #eee; padding: 20px; line-height: 1.6; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: #00d4ff; margin-bottom: 10px; font-size: 2em; }
        .subtitle { color: #aaa; margin-bottom: 30px; font-size: 0.95em; }
        
        /* UPLOAD SECTION */
        .upload-section { background: #16213e; border: 2px dashed #00d4ff; border-radius: 12px; padding: 40px; text-align: center; margin-bottom: 30px; transition: all 0.3s; }
        .upload-section:hover { border-color: #00ffaa; background: #1a2744; }
        input[type="file"] { display: none; }
        .upload-btn { background: linear-gradient(135deg, #00d4ff, #0099cc); color: white; padding: 15px 40px; border: none; border-radius: 8px; font-size: 1.1em; cursor: pointer; transition: transform 0.2s; font-weight: 600; }
        .upload-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4); }
        #fileNameDisplay { margin-top: 15px; font-size: 1.1em; font-weight: bold; color: #00ffaa; display: none; }

        /* CONTROLS & INPUTS */
        .controls { background: #16213e; border-radius: 12px; padding: 25px; margin-bottom: 30px; display: none; }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; color: #00d4ff; font-weight: 600; font-size: 0.95em; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 12px; background: #0f1626; border: 1px solid #2a3f5f; border-radius: 6px; color: #eee; font-size: 1em; }
        select { appearance: none; background: #0f1626 url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%20viewBox%3D%220%200%2012%2012%22%3E%3Cpath%20fill%3D%22%2300D4FF%22%20d%3D%22M10%203L6%207L2%203L0%205L6%2011L12%205L10%203Z%22%2F%3E%3C%2Fsvg%3E") no-repeat right 12px center; background-size: 12px; cursor: pointer; }
        input:focus, select:focus { outline: none; border-color: #00d4ff; }
        
        /* BUTTONS */
        .btn { background: linear-gradient(135deg, #00d4ff, #0099cc); color: white; padding: 14px 30px; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; transition: all 0.2s; font-weight: 600; width: 100%; }
        .btn:disabled { background: #555; cursor: not-allowed; transform: none; }
        .export-btn { width: auto !important; padding: 10px 15px; font-size: 0.9em; margin-left: 10px; }
        .export-btn:hover { box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4); }

        /* PROGRESS BAR */
        .progress { display: none; background: #16213e; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .progress-bar { width: 100%; height: 30px; background: #0f1626; border-radius: 15px; overflow: hidden; margin-bottom: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #00d4ff, #00ffaa); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
        .progress-text { color: #aaa; text-align: center; }

        /* SELECTION UI */
        .selection-status { color: #00d4ff; font-weight: bold; margin-bottom: 15px; }
        .selection-slot { flex: 1; background: #0f1626; border-radius: 8px; padding: 15px; border: 2px solid #2a3f5f; min-height: 80px; transition: all 0.3s; }
        #slot1 { border-color: #00ffaa; } 
        #slot2 { border-color: #ffaa00; }
        .slot-header { color: #aaa; font-size: 0.8em; font-weight: 600; margin-bottom: 5px; text-transform: uppercase; }
        .slot-name-active { font-size: 1.2em; font-weight: 700; color: #eee; display: flex; justify-content: space-between; align-items: center; }
        .remove-btn { background: transparent; border: none; color: #ff6347; cursor: pointer; font-weight: bold; font-size: 0.9em; padding: 5px 10px; border-radius: 4px; }
        .remove-btn:hover { background: rgba(255, 99, 71, 0.2); }
        .sheet-button-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; padding: 15px; background: #0f1626; border-radius: 8px; border: 1px solid #2a3f5f; }
        .sheet-option { background: #16213e; color: #eee; padding: 10px 15px; border: 1px solid #2a3f5f; border-radius: 6px; font-size: 0.9em; cursor: pointer; transition: all 0.2s; font-weight: 500; }
        .sheet-option:hover { background: #0f1626; border-color: #00d4ff; }
        .sheet-option.selected { background: #00d4ff; color: #1a1a2e; border-color: #00d4ff; font-weight: 700; box-shadow: 0 0 10px rgba(0, 212, 255, 0.5); }

        /* CHECKBOXES */
        .checkbox-container { border: 1px solid #2a3f5f; border-radius: 6px; padding: 10px; height: 150px; overflow-y: auto; background: #0f1626; }
        .checkbox-item { display: flex; align-items: center; padding: 4px 0; cursor: pointer; }
        .checkbox-item:hover { background: #1a2744; }
        .checkbox-item input { margin-right: 8px; }
        .checkbox-item label { cursor: pointer; flex-grow: 1; color: #eee; }
        
        /* RESULTS */
        .results { display: none; }
        .stats { background: #16213e; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 2em; color: #00d4ff; font-weight: bold; }
        .stat-label { color: #aaa; font-size: 0.9em; margin-top: 5px; }
        
        /* VIEW TOGGLES */
        .view-toggle { display: flex; justify-content: center; margin-bottom: 20px; gap: 15px; }
        .view-btn { background: #16213e; border: 1px solid #2a3f5f; color: #aaa; padding: 10px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; }
        .view-btn.active { background: #00d4ff; color: #1a1a2e; border-color: #00d4ff; box-shadow: 0 0 15px rgba(0, 212, 255, 0.4); }

        /* TABLE */
        .match-group { background: #16213e; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .match-header { color: #00d4ff; font-size: 1.2em; font-weight: bold; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #2a3f5f; display: flex; justify-content: space-between; align-items: center; }
        .table-container { overflow-x: auto; max-height: 450px; border: 1px solid #2a3f5f; border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        th, td { padding: 12px; border-bottom: 1px solid #2a3f5f; }
        th { background: #0f1626; color: #00d4ff; text-align: left; font-weight: 600; position: sticky; top: 0; z-index: 11; }
        tr:hover { background: #1a2744; }
        .highlight { background: rgba(0, 212, 255, 0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600; }
        .tab-badge { background: rgba(0, 212, 255, 0.2); color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 0.85em; display: inline-block; white-space: nowrap; margin-right: 5px; }

        /* EXPORT BUTTONS LAYOUT */
        #exportButtonContainer { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; }
        #exportButtonContainer .btn { flex: 1; min-width: 250px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíæ Excel Data Utility (IndexedDB & Grouping)</h1>
        <p class="subtitle">Robust data processing with Web Workers. <strong>Open Console (F12) for logs.</strong></p>

        <div class="upload-section">
            <input type="file" id="fileInput" accept=".xlsx,.xls">
            <label for="fileInput" class="upload-btn">Choose Excel File</label>
            <div id="fileNameDisplay"></div>
        </div>

        <div class="controls" id="controls">
            <label class="selection-status" id="selectionStatus">STEP 1: Select Sheet(s)</label>
            <div id="selectionVisualizer" style="display: flex; gap: 20px; margin-bottom: 20px;">
                <div id="slot1" class="selection-slot"><div class="slot-header">Source Sheet (1)</div><div id="slot1Name">Click a sheet below...</div></div>
                <div id="slot2" class="selection-slot"><div class="slot-header">Target Sheet (2)</div><div id="slot2Name">Click a second sheet...</div></div>
            </div>
            <div id="sheetSelector" class="sheet-button-list"></div>

            <div id="groupingControls" style="display: none; border: 2px solid #00ffaa; border-radius: 12px; padding: 25px; margin-bottom: 30px;">
                <h3 style="color: #00ffaa; margin-bottom: 15px;">üìä Data Grouping (Single Sheet)</h3>
                <p style="color: #aaa; margin-bottom: 15px;">Select columns to group data by unique values (e.g., Department).</p>
                <div class="control-group">
                    <label id="groupingColLabel">Columns to Group By</label>
                    <div id="groupingColsContainer" class="checkbox-container" style="height: 200px;"></div>
                </div>
                <div style="display: flex; gap: 15px; margin-top: 20px;">
                    <button class="btn" id="groupBtn" disabled style="background: linear-gradient(135deg, #10ac84, #009473); flex: 1;">üöÄ Group Data by Selected Columns</button>
                    <button class="btn" id="dedupeBtn" style="background: linear-gradient(135deg, #f06, #c03); flex: 1;">üßπ Find Exact Duplicates (All Cols)</button>
                </div>
            </div>

            <div id="matchControls" style="display: none;">
                <div class="control-group"><div class="checkbox-group"><input type="checkbox" id="dedupeSourceSheets" checked><label for="dedupeSourceSheets">üßº Pre-Clean Source Sheets</label></div></div>
                <div class="control-group"><div class="checkbox-group"><input type="checkbox" id="robustExactMatch"><label for="robustExactMatch">üí™ Enable Robust Exact Match</label></div></div>
                <div class="control-group"><div class="checkbox-group"><input type="checkbox" id="removeDuplicates" checked><label for="removeDuplicates">üßπ Remove Cross-Sheet Duplicates</label></div></div>
                
                <div id="ignoreControls" style="display: block; border-top: 1px solid #2a3f5f; padding-top: 20px; margin-bottom: 20px;">
                    <h3 style="color: #ffaa00;">üö´ Columns to IGNORE (Exhaustive Match Only)</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div><label id="ignoreCol1Label">Ignore Sheet 1</label><div id="ignoreCols1Container" class="checkbox-container"></div></div>
                        <div><label id="ignoreCol2Label">Ignore Sheet 2</label><div id="ignoreCols2Container" class="checkbox-container"></div></div>
                    </div>
                </div>

                <div class="control-group"><div class="checkbox-group"><input type="checkbox" id="fuzzyMatch"><label for="fuzzyMatch">‚ú® Enable Fuzzy Matching</label></div></div>
                <div class="control-group" id="fuzzyOptions" style="display: none;"><label>Fuzzy Threshold</label><input type="number" id="fuzzyThreshold" min="0" max="100" value="20" step="5"></div>
                
                <div id="targetedMatchControls" style="border-top: 1px solid #2a3f5f; padding-top: 20px;">
                    <h3 style="color: #00ffaa;">üéØ Targeted Column Match</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div><label id="col1Label">Sheet 1 Column</label><select id="column1Selector"></select></div>
                        <div><label id="col2Label">Sheet 2 Column</label><select id="column2Selector"></select></div>
                    </div>
                    <button class="btn" id="targetedMatchBtn" style="margin-top: 20px;">üéØ Run Targeted Match</button>
                </div>
                <button class="btn" id="matchBtn" disabled>Find All Potential Matches (Exhaustive)</button>
            </div>
        </div>

        <div class="progress" id="progress"><div class="progress-bar"><div class="progress-fill" id="progressFill">0%</div></div><div class="progress-text" id="progressText">Waiting...</div></div>

        <div class="results" id="results">
            <div class="stats" id="stats"></div>
            <div class="info" id="resultsInfo"></div>
            
            <div class="view-toggle" id="viewToggleContainer" style="display: none;">
                <button class="view-btn active" id="viewTableBtn" onclick="switchView('table')">üìã Table View</button>
                <button class="view-btn" id="viewRelBtn" onclick="switchView('relationship')">üîó Relationship Explorer</button>
                <button class="view-btn" id="viewNetBtn" onclick="switchView('network')">üï∏Ô∏è Network Graph</button>
            </div>

            <div id="tableViewContainer">
                 <div id="exportIgnoreControls" class="controls" style="display: none; padding: 20px; margin-bottom: 20px;">
                    <h3 style="color: #ffaa00;">üì• Columns to Exclude from EXPORT</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div><label id="exportIgnoreCol1Label">Exclude Sheet 1</label><div id="exportIgnoreCols1Container" class="checkbox-container"></div></div>
                        <div><label id="exportIgnoreCol2Label">Exclude Sheet 2</label><div id="exportIgnoreCols2Container" class="checkbox-container"></div></div>
                    </div>
                </div>
                
                <div class="match-groups" id="matchGroups"></div>
                <div id="exportButtonContainer">
                    <button class="btn" id="exportAllToSingleSheetBtn" style="background: linear-gradient(135deg, #3498db, #2980b9);">üìä Export All Groups to Single Sheet</button>
                    <button class="btn" id="exportAllToTabsBtn" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">üìë Export Each Group to Separate Tab</button>
                    <button class="btn" id="exportAllBtn" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">Export to Workbook</button>
                </div>
            </div>

            <div id="relationshipViewContainer" style="display: none;">
                <div class="info" style="background: #2a3f5f; border-left: 5px solid #00ffaa;"><h3>üîó Relationship Explorer</h3><p>Grouped by Source Row.</p></div>
                <div class="relationship-container" id="relationshipContent"></div>
            </div>
            
            <div id="networkViewContainer" style="display: none;">
                <div class="info" style="background: #2a3f5f; border-left: 5px solid #00d4ff;"><h3>üï∏Ô∏è Network Graph</h3></div>
                <div class="network-legend" id="networkLegend"></div>
                <div id="networkGraph"></div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const DB_NAME = 'ExcelDataUtilityDB';
        const DB_VERSION = 2; 
        const ROW_STORE_PREFIX = 'Sheet_';
        const METADATA_STORE_NAME = 'SheetMetadata';
        
        // --- STATE ---
        let db = null;
        let selectedSheets = [];
        let allMatches = [];
        let groupedData = null;
        let uniqueSheetData = null;
        let duplicateRowsData = null;
        let sheetNames = [];
        let sheetHeaders = {};
        let currentFilteredGroups = [];

        // --- DOM ELEMENTS ---
        const els = {
            fileInput: document.getElementById('fileInput'),
            fileNameDisplay: document.getElementById('fileNameDisplay'),
            controls: document.getElementById('controls'),
            results: document.getElementById('results'),
            progress: document.getElementById('progress'),
            progressBar: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            sheetSelector: document.getElementById('sheetSelector'),
            slot1: document.getElementById('slot1Name'),
            slot2: document.getElementById('slot2Name'),
            matchBtn: document.getElementById('matchBtn'),
            dedupeBtn: document.getElementById('dedupeBtn'),
            groupBtn: document.getElementById('groupBtn'),
            targetedMatchBtn: document.getElementById('targetedMatchBtn'),
            exportAllBtn: document.getElementById('exportAllBtn'),
            exportAllSingleBtn: document.getElementById('exportAllToSingleSheetBtn'),
            exportAllTabsBtn: document.getElementById('exportAllToTabsBtn'),
            
            // Sections
            groupingControls: document.getElementById('groupingControls'),
            matchControls: document.getElementById('matchControls'),
            ignoreControls: document.getElementById('ignoreControls'),
            exportIgnoreControls: document.getElementById('exportIgnoreControls'),
            
            // Inputs
            column1Selector: document.getElementById('column1Selector'),
            column2Selector: document.getElementById('column2Selector'),
            ignoreCols1: document.getElementById('ignoreCols1Container'),
            ignoreCols2: document.getElementById('ignoreCols2Container'),
            groupingCols: document.getElementById('groupingColsContainer'),
            exportIgnore1: document.getElementById('exportIgnoreCols1Container'),
            exportIgnore2: document.getElementById('exportIgnoreCols2Container'),
            
            // Views
            views: {
                toggle: document.getElementById('viewToggleContainer'),
                table: document.getElementById('tableViewContainer'),
                rel: document.getElementById('relationshipViewContainer'),
                net: document.getElementById('networkViewContainer')
            }
        };

        // --- EVENT LISTENERS ---
        els.fileInput.addEventListener('change', handleFile);
        
        els.matchBtn.addEventListener('click', () => startMatching(false));
        els.targetedMatchBtn.addEventListener('click', () => startMatching(true));
        
        els.dedupeBtn.addEventListener('click', startDeduplication);
        els.groupBtn.addEventListener('click', startGrouping);
        
        els.exportAllBtn.addEventListener('click', exportResults);
        els.exportAllSingleBtn.addEventListener('click', exportAllToSingleSheet);
        els.exportAllTabsBtn.addEventListener('click', exportAllToTabs);
        
        document.getElementById('fuzzyMatch').addEventListener('change', (e) => {
            document.getElementById('fuzzyOptions').style.display = e.target.checked ? 'block' : 'none';
        });

        // --- FILE HANDLING & DB INIT ---
        async function initDB() {
            db = await idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db) {
                    if (!db.objectStoreNames.contains(METADATA_STORE_NAME)) {
                        db.createObjectStore(METADATA_STORE_NAME, { keyPath: 'sheetName' });
                    }
                }
            });
        }

        async function deleteCurrentDB() {
            if (db) { db.close(); }
            await idb.deleteDB(DB_NAME);
        }

        function createParsingWorker() {
            const script = `
                self.onerror = function(err) {
                    console.error('Worker global error:', err);
                    self.postMessage({type:'error', msg: 'Worker error: ' + (err.message || err)});
                };
                
                importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
                importScripts('https://cdn.jsdelivr.net/npm/idb@7.1.1/build/umd.js');
                const DB_NAME = 'ExcelDataUtilityDB'; const DB_VER = 2;
                
                self.onmessage = async (e) => {
                    try {
                        self.postMessage({type:'progress', text:'Loading libraries...'});
                        const data = new Uint8Array(e.data.buffer);
                        self.postMessage({type:'progress', text:'Reading file...'});
                        const wb = XLSX.read(data, {type:'array'});
                        self.postMessage({type:'progress', text:'Found ' + wb.SheetNames.length + ' sheets'});
                        
                        const db = await idb.openDB(DB_NAME, DB_VER, {
                            upgrade(db) {
                                if (!db.objectStoreNames.contains('SheetMetadata')) 
                                    db.createObjectStore('SheetMetadata', { keyPath: 'sheetName' });
                                wb.SheetNames.forEach(n => {
                                    const name = 'Sheet_' + n;
                                    if(!db.objectStoreNames.contains(name)) 
                                        db.createObjectStore(name, { keyPath: 'id', autoIncrement: true });
                                });
                            }
                        });

                        const tx = db.transaction(db.objectStoreNames, 'readwrite');
                        
                        for(const name of wb.SheetNames) {
                            self.postMessage({type:'progress', text:'Processing: ' + name});
                            const ws = wb.Sheets[name];
                            const json = XLSX.utils.sheet_to_json(ws, {header:1, defval:'', raw:true, cellDates:false});
                            
                            const processed = json.map(row => row.map(cell => {
                                if(typeof cell === 'number' && cell > 1 && cell < 100000) return XLSX.SSF.format('yyyy-mm-dd', cell);
                                return (cell === null || cell === undefined) ? '' : String(cell);
                            }));
                            
                            const headers = processed[0] || [];
                            const rows = processed.slice(1);
                            
                            await tx.objectStore('SheetMetadata').put({sheetName: name, headers: headers, totalRows: rows.length});
                            const store = tx.objectStore('Sheet_' + name);
                            for(const r of rows) store.add({data: r});
                        }
                        
                        await tx.done;
                        db.close();
                        self.postMessage({type:'complete', sheets: wb.SheetNames});
                    } catch(err) {
                        self.postMessage({type:'error', msg: err.message || String(err)});
                    }
                };
            `;
            const blob = new Blob([script], {type:'application/javascript'});
            return new Worker(URL.createObjectURL(blob));
        }

        async function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('File selected:', file.name, 'Size:', file.size);
            els.fileNameDisplay.textContent = "üìÇ " + file.name;
            els.fileNameDisplay.style.display = 'block';
            els.progress.style.display = 'block';
            els.progressText.textContent = "Initializing...";
            els.controls.style.display = 'none';
            
            try {
                await deleteCurrentDB();
                console.log('Database cleared');
            } catch(err) {
                console.error('DB delete error:', err);
            }
            
            const reader = new FileReader();
            reader.onerror = (err) => {
                console.error('FileReader error:', err);
                alert("Error reading file: " + err.message);
                els.progress.style.display = 'none';
            };
            
            reader.onload = (evt) => {
                try {
                    console.log('File loaded, creating worker...');
                    const worker = createParsingWorker();
                    
                    worker.onerror = (err) => {
                        console.error('Worker error event:', err.message || err);
                        console.error('Worker error filename:', err.filename);
                        console.error('Worker error lineno:', err.lineno);
                        alert("Worker Error: " + (err.message || String(err)));
                        worker.terminate();
                        els.progress.style.display = 'none';
                    };
                    
                    console.log('Worker created, sending data...');
                    worker.postMessage({buffer: evt.target.result}, [evt.target.result]);
                    
                    worker.onmessage = async (msg) => {
                        try {
                            console.log('Main received:', msg.data.type);
                            if(msg.data.type === 'progress') {
                                els.progressText.textContent = msg.data.text;
                            } else if(msg.data.type === 'complete') {
                                console.log('File parsing complete');
                                await initDB();
                                await loadMetadata();
                                renderSheetButtons();
                                els.progress.style.display = 'none';
                                els.controls.style.display = 'block';
                                updateSelectionUI();
                                worker.terminate();
                            } else if(msg.data.type === 'error') {
                                alert("Worker Error: " + msg.data.msg);
                                console.error('Worker reported error:', msg.data.msg);
                                worker.terminate();
                                els.progress.style.display = 'none';
                            }
                        } catch(err) {
                            console.error('Message handler error:', err);
                            alert("Error processing message: " + err.message);
                        }
                    };
                } catch(err) {
                    console.error('Worker creation error:', err);
                    alert("Error creating worker: " + err.message);
                    els.progress.style.display = 'none';
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        async function loadMetadata() {
            const meta = await db.getAll(METADATA_STORE_NAME);
            sheetNames = meta.map(m => m.sheetName);
            meta.forEach(m => sheetHeaders[m.sheetName] = m.headers);
        }

        // --- SHEET SELECTION LOGIC ---
        function toggleSheet(name) {
            const idx = selectedSheets.indexOf(name);
            if (idx > -1) selectedSheets.splice(idx, 1);
            else {
                if (selectedSheets.length < 2) selectedSheets.push(name);
                else selectedSheets = [name];
            }
            updateSelectionUI();
        }

        function renderSheetButtons() {
            els.sheetSelector.innerHTML = '';
            sheetNames.forEach(name => {
                const div = document.createElement('div');
                div.className = 'sheet-option';
                div.textContent = name;
                div.onclick = () => toggleSheet(name);
                els.sheetSelector.appendChild(div);
            });
        }

        async function updateSelectionUI() {
            Array.from(els.sheetSelector.children).forEach(btn => {
                if (selectedSheets.includes(btn.textContent)) btn.classList.add('selected');
                else btn.classList.remove('selected');
            });

            els.slot1.textContent = selectedSheets[0] || "Select a sheet...";
            els.slot1.className = selectedSheets[0] ? 'slot-name-active' : 'slot-name-placeholder';
            els.slot2.textContent = selectedSheets[1] || "Select a second sheet...";
            els.slot2.className = selectedSheets[1] ? 'slot-name-active' : 'slot-name-placeholder';

            els.results.style.display = 'none';
            els.groupingControls.style.display = 'none';
            els.matchControls.style.display = 'none';
            
            if (selectedSheets.length === 1) {
                els.groupingControls.style.display = 'block';
                document.getElementById('groupingColLabel').textContent = `Columns to Group By (${selectedSheets[0]})`;
                populateCheckboxes(els.groupingCols, sheetHeaders[selectedSheets[0]], 'group');
            } else if (selectedSheets.length === 2) {
                els.matchControls.style.display = 'block';
                populateSelect(els.column1Selector, sheetHeaders[selectedSheets[0]]);
                populateSelect(els.column2Selector, sheetHeaders[selectedSheets[1]], true);
                
                populateCheckboxes(els.ignoreCols1, sheetHeaders[selectedSheets[0]], 'ig1');
                populateCheckboxes(els.ignoreCols2, sheetHeaders[selectedSheets[1]], 'ig2');
                
                populateCheckboxes(els.exportIgnore1, sheetHeaders[selectedSheets[0]], 'ex1');
                populateCheckboxes(els.exportIgnore2, sheetHeaders[selectedSheets[1]], 'ex2');
                els.exportIgnoreControls.style.display = 'block';
            }
        }

        // --- HELPER UI FUNCTIONS ---
        function populateSelect(select, headers, addAll = false) {
            select.innerHTML = '';
            if(addAll) {
                const opt = document.createElement('option');
                opt.value = 'all'; opt.textContent = '-- All Columns --';
                select.appendChild(opt);
            }
            headers.forEach((h, i) => {
                const opt = document.createElement('option');
                opt.value = i; opt.textContent = h || `Col ${i+1}`;
                select.appendChild(opt);
            });
        }

        function populateCheckboxes(container, headers, prefix) {
            container.innerHTML = '';
            headers.forEach((h, i) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                div.innerHTML = `<input type="checkbox" id="${prefix}_${i}" value="${i}"><label for="${prefix}_${i}">${h || `Col ${i+1}`}</label>`;
                div.onclick = (e) => {
                    if(e.target.tagName !== 'INPUT') {
                        const cb = div.querySelector('input');
                        cb.checked = !cb.checked;
                    }
                    if(prefix === 'group') checkGroupBtn();
                };
                container.appendChild(div);
            });
        }

        function getCheckedIndices(container) {
            return Array.from(container.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
        }

        function checkGroupBtn() {
            els.groupBtn.disabled = getCheckedIndices(els.groupingCols).length === 0;
        }

        // --- WORKER CREATION (GROUPING) ---
        function createGroupingWorker() {
            const script = `
                importScripts('https://cdn.jsdelivr.net/npm/idb@7.1.1/build/umd.js');
                const DB_NAME = 'ExcelDataUtilityDB'; const DB_VER = 2;
                
                async function getAllRows(db, store) {
                    const rows = [];
                    let cursor = await db.transaction(store).store.openCursor();
                    while(cursor) { rows.push(cursor.value.data); cursor = await cursor.continue(); }
                    return rows;
                }

                self.onmessage = async (e) => {
                    try {
                        const { sheet, cols } = e.data;
                        const db = await idb.openDB(DB_NAME, DB_VER);
                        const raw = await getAllRows(db, 'Sheet_' + sheet);
                        db.close();
                        
                        const headers = raw[0];
                        const rows = raw.slice(1);
                        const groups = {};

                        rows.forEach((r, idx) => {
                            const key = cols.map(c => String(r[c]||'').trim()).join(' | ');
                            if(!groups[key]) groups[key] = { key, rows: [], keyVals: cols.map(c => r[c]) };
                            groups[key].rows.push({ origIdx: idx, data: r });
                        });

                        self.postMessage({
                            type: 'result', 
                            groups: Object.values(groups),
                            headers: headers
                        });
                    } catch(err) {
                        self.postMessage({type:'error', msg: err.message});
                    }
                };
            `;
            const blob = new Blob([script], {type:'application/javascript'});
            return new Worker(URL.createObjectURL(blob));
        }

        // --- ACTION: GROUPING ---
        function startGrouping() {
            const cols = getCheckedIndices(els.groupingCols);
            if(cols.length === 0) return;
            
            els.progress.style.display = 'block';
            els.results.style.display = 'none';
            els.progressText.textContent = "Grouping data...";
            
            const worker = createGroupingWorker();
            worker.onerror = (e) => { alert("Worker Error: " + e.message); };
            
            worker.postMessage({ sheet: selectedSheets[0], cols: cols });
            
            worker.onmessage = (e) => {
                if(e.data.type === 'result') {
                    groupedData = { 
                        groups: e.data.groups, 
                        headers: e.data.headers, 
                        sheetName: selectedSheets[0],
                        groupCols: cols
                    };
                    displayGroupingResults();
                    worker.terminate();
                } else if (e.data.type === 'error') {
                    alert(e.data.msg);
                    worker.terminate();
                }
            };
        }

        function displayGroupingResults() {
            els.progress.style.display = 'none';
            els.results.style.display = 'block';
            
            els.views.toggle.style.display = 'none';
            els.views.table.style.display = 'block';
            
            const totalRows = groupedData.groups.reduce((a, b) => a + b.rows.length, 0);
            document.getElementById('stats').innerHTML = `
                <div class="stat-item"><div class="stat-value">${totalRows}</div><div class="stat-label">Total Rows</div></div>
                <div class="stat-item"><div class="stat-value">${groupedData.groups.length}</div><div class="stat-label">Unique Groups</div></div>
                <div class="stat-item"><div class="stat-value">${groupedData.sheetName}</div><div class="stat-label">Sheet</div></div>
            `;

            const container = document.getElementById('matchGroups');
            container.innerHTML = '';
            
            groupedData.groups.forEach(g => g.keep = true);
            
            els.exportAllSingleBtn.style.display = 'inline-block';
            els.exportAllTabsBtn.style.display = 'inline-block';
            els.exportAllBtn.style.display = 'none';
            updateGroupingExportText();

            groupedData.groups.slice(0, 50).forEach((g, i) => {
                const div = document.createElement('div');
                div.className = 'match-group';
                const keyDisplay = g.keyVals.map((val, idx) => {
                    const hIndex = groupedData.groupCols[idx];
                    return `<span class="tab-badge">${groupedData.headers[hIndex]}: ${val}</span>`;
                }).join('');
                
                div.innerHTML = `
                    <div class="match-header">
                        <div>Group ${i+1}: ${keyDisplay} (${g.rows.length} rows)</div>
                        <div>
                            <button class="btn export-btn" onclick="toggleGroup(${i})">Toggle Export</button>
                        </div>
                    </div>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>Row #</th>${groupedData.headers.map(h=>`<th>${h}</th>`).join('')}</tr></thead>
                            <tbody>
                                ${g.rows.slice(0,10).map(r => 
                                    `<tr><td>${r.origIdx+2}</td>${r.data.map(c=>`<td>${c}</td>`).join('')}</tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        window.toggleGroup = function(idx) {
            groupedData.groups[idx].keep = !groupedData.groups[idx].keep;
            updateGroupingExportText();
        }

        function updateGroupingExportText() {
            const count = groupedData.groups.filter(g => g.keep).reduce((a,b)=>a+b.rows.length,0);
            els.exportAllSingleBtn.textContent = `üìä Export All Groups to Single Sheet (${count} rows)`;
            els.exportAllTabsBtn.textContent = `üìë Export Each Group to Separate Tab (${groupedData.groups.filter(g => g.keep).length} groups)`;
        }

        // --- EXPORT TO SINGLE SHEET ---
        function exportAllToSingleSheet() {
            if(groupedData) {
                const wb = XLSX.utils.book_new();
                let exportRows = [['Group Key', 'Original Row', ...groupedData.headers]];
                
                groupedData.groups.filter(g => g.keep).forEach(g => {
                    g.rows.forEach(r => {
                        exportRows.push([g.key, r.origIdx+2, ...r.data]);
                    });
                });
                
                if(exportRows.length === 1) return alert("No groups selected.");
                
                const ws = XLSX.utils.aoa_to_sheet(exportRows);
                XLSX.utils.book_append_sheet(wb, ws, "Grouped Data");
                XLSX.writeFile(wb, "Grouped_Export.xlsx");
            }
        }

        // --- EXPORT TO SEPARATE TABS (NEW) ---
        function exportAllToTabs() {
            if(!groupedData) return;

            const wb = XLSX.utils.book_new();
            const selectedGroups = groupedData.groups.filter(g => g.keep);

            if(selectedGroups.length === 0) {
                alert("No groups selected.");
                return;
            }

            selectedGroups.forEach((g, idx) => {
                const sheetData = [groupedData.headers];
                g.rows.forEach(r => {
                    sheetData.push(r.data);
                });

                // Create sheet name from group key, sanitize for Excel
                let sheetName = g.key.substring(0, 30).replace(/[\/\\?*[\]:]/g, '_');
                if(!sheetName) sheetName = `Group_${idx + 1}`;
                if(sheetName.length > 31) sheetName = sheetName.substring(0, 31);

                const ws = XLSX.utils.aoa_to_sheet(sheetData);
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });

            XLSX.writeFile(wb, "Grouped_By_Tabs.xlsx");
        }

        // --- ACTION: DEDUPLICATION ---
        async function startDeduplication() {
            const sheet = selectedSheets[0];
            const db = await idb.openDB(DB_NAME, 2);
            const tx = db.transaction('Sheet_' + sheet);
            const raw = await tx.store.getAll();
            
            const rows = raw.map(x => x.data);
            const seen = new Set();
            const unique = [];
            const dupe = [];
            
            const headers = rows[0];
            const data = rows.slice(1);
            
            data.forEach(r => {
                const k = JSON.stringify(r);
                if(seen.has(k)) dupe.push(r);
                else { seen.add(k); unique.push(r); }
            });
            
            document.getElementById('stats').innerHTML = `<div class="stat-item"><div class="stat-value">${unique.length}</div><div class="stat-label">Unique</div></div><div class="stat-item"><div class="stat-value">${dupe.length}</div><div class="stat-label">Duplicates</div></div>`;
            uniqueSheetData = [headers, ...unique];
            
            db.close();
            window.exportUniqueSheet(sheet);
        }
        
        window.exportUniqueSheet = function(name) {
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(uniqueSheetData), "Unique");
            XLSX.writeFile(wb, "Unique_Data.xlsx");
        }

        // --- VIEW SWITCHING ---
        window.switchView = function(mode) {
            Object.values(els.views).forEach(el => { if(el) el.style.display = 'none'; });
            document.getElementById('viewTableBtn').className = 'view-btn';
            document.getElementById('viewRelBtn').className = 'view-btn';
            document.getElementById('viewNetBtn').className = 'view-btn';
            
            if(mode === 'table') {
                els.views.table.style.display = 'block';
                document.getElementById('viewTableBtn').classList.add('active');
            }
        }

        // Placeholder functions for matching
        function startMatching(targeted) {
            alert("Matching functionality coming soon");
        }
        
        function exportResults() {
            alert("Export functionality for matching results coming soon");
        }

    </script>
</body>
</html>